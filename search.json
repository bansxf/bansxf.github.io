[{"categories":["Git"],"content":"在使用git push，解决电脑里的其他干扰账号。\n运行下列清除用户名密码的指令\n1  git credential-manager uninstall   ","description":"仅供学习参考","tags":["解决问题"],"title":"清除用户名和密码","uri":"/posts/git/%E6%B8%85%E9%99%A4%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/"},{"categories":["Web安全漏洞"],"content":"CSRF又叫跨站请求伪造，是一种Web漏洞。\n简介 CSRF（Cross-site request forery,跨站请求伪造）也被称为One Click Attack或者Session Riding ,通常缩写为CSRF或者XSRF\n参数被被恶意攻击者猜测到，利用目标用户的合法身份，忽悠目标用户点击链接，完成某些非法操作。典型例子：QQ空间自动转发说说。\n防御：\n验证http referer字段\n在请求地址中添加token，并验证\n在http头中自定属性并验证\nget型csrf利用：\n1  \u003cimg src=\"https://target.php?uname=123 passworld=123\"\u003e   post csrf利用：设置form表单提交\n1  \u003cinput type=\"hidden\" name=\"username\" value=\"1111\"/\u003e   自动化探测 burp探测 特征：\n重放请求，无一次性token或验证码\nreferer去掉后重放请求，无referer验证\n去掉token后重放，后端认证机制薄弱\nCSRFTester探测 代理抓取链接和表单信息通过在工具中修改，再重新提交，如果测试的请求被网站服务器所接受，那么存在csrf漏洞。\n步骤：\n1.设置浏览器代理:127.0.0.1:8008\n2.登录web应用程序，提交表单，在csrf工具中修改表单内容，查看是否更改，如更改表面存在csrf漏洞。\n3.生产poc（观点验证程序）代码。\n漏洞利用 漏洞实质是服务器无法判断当前请求是否是合法账户的自定义请求。\n使用服务器搭建csrf poc访问页面，在kali中,/var/www/html,下的index.html要被替换为工具生成的index.html（或者用一个站点的页面嵌入poc代码） ，修改一下ip,类似下面这句\n1  \u003cform method=\"POST\" name=\"form10\" action=\"http://127.0.0.1:80/espcms/espcms_admin/index.php?act=tExyZnjRRCSmgu2bgcaOZesWvaDlNc6yRugESP1ac3Y=\"\u003e   127.0.0.1改为目标站点地址，在合法用户登录后并点击了该链接，即可达成攻击目的。\nget型利用 链接利用：a\n1  \u003ca href=\"\"\u003e   iframe利用：\n1  \u003ciframe src=\"\" style=\"display:none\"\u003e   img标签利用：\n1  \u003cimg src=\"\"\u003e   css中background利用：\n1  \u003ch1 style=\"background:url()\"\u003e   漏洞防御 token防御 用户登录后，服务器会发给用户一个唯一的合法令牌，会随用户form表单中的value隐藏提交。\n登录验证成功后，再会话session[“user_token”]中保存token。\n在后台操作中，增删改表单中添加隐藏域hidden，设置value为token。\n提交之后进行验证token是否正确。\n防御措施\n生成一个随机且不被轻易猜测的参数。\ntoken泄露\nget型token泄露：页面包含\n1  \u003cimg src=\"\"\u003e   那么请求中的referer就会携带对应的get token.\npost型token泄露：\n利用xss漏洞读取cookie,获取讯处在其中的token值。\nreferer防御 referer用来告诉服务器该请求来自哪个页面。\n代码编写： 绕过技巧：创建一个带目标服务器的ip的目录 burp自动生成poc:pro\n验证码防御 并不能每部 都用验证码，并不是主要防御方法。\nreferer check防御 主要用于防止盗链，同理也可以用于检查请求是否来自合法的源\n缺陷：不是任何时候都会携带referer头，如https转http\n","description":"仅供学习参考","tags":["CSRF"],"title":"CSRF漏洞","uri":"/posts/web%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/csrf%E6%BC%8F%E6%B4%9E/"},{"categories":["Web安全漏洞"],"content":"CORS又叫跨域资源共享\nCORS实现请求跨域 转载于：https://blog.csdn.net/badmoonc/article/details/82706246\n简介 CORS：全称\"跨域资源共享\"（Cross-origin resource sharing）。\nCORS需要浏览器和服务器同时支持，才可以实现跨域请求，目前几乎所有浏览器都支持CORS，IE则不能低于IE10。CORS的整个过程都由浏览器自动完成，前端无需做任何设置，跟平时发送ajax请求并无差异。so，实现CORS的关键在于服务器，只要服务器实现CORS接口，就可以实现跨域通信。\n请求类型： CORS分为简单请求和非简单请求(需预检请求)两类\n符合以下条件的，为简单请求\n请求方式使用下列方法之一： GET HEAD POST Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 对于简单请求，浏览器会直接发送CORS请求，具体说来就是在header中加入origin请求头字段。同样，在响应头中，返回服务器设置的相关CORS头部字段，Access-Control-Allow-Origin字段为允许跨域请求的源。请求时浏览器在请求头的Origin中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回，具体如下：\n在这里，http://localhost:3001为我们当前发送请求的源，如果服务器发现请求在指定的源范围内，则会返回响应的请求结果， 否则会在控制台报错，如下图所示，在这里需要注意的是，尽管请求失败，但返回的状态码依然可能为200。所以在做处理时需要格外注意。\n非简单请求(预检请求)\n使用了下面任一 HTTP 方法： PUT DELETE CONNECT OPTIONS TRACE PATCH Content-Type 的值不属于下列之一: application/x-www-form-urlencoded multipart/form-data text/plain 当发生符合非简单请求（预检请求）的条件时，浏览器会自动先发送一个options请求，如果发现服务器支持该请求，则会将真正的请求发送到后端，反之，如果浏览器发现服务端并不支持该请求，则会在控制台抛出错误，如下：\n如果非简单请求（预检请求）发送成功，则会在头部多返回以下字段\nAccess-Control-Allow-Origin: http://localhost:3001 //该字段表明可供那个源跨域 Access-Control-Allow-Methods: GET, POST, PUT // 该字段表明服务端支持的请求方法 Access-Control-Allow-Headers: X-Custom-Header // 实际请求将携带的自定义请求首部字段 下图为一个预检请求实例：\n红框标注的为预检请求发送的查询，服务端支持我们的请求后，将会发送我们真正的请求，图中绿框所示。可以看到，真正的请求响应头字段多处蓝框中所圈字段。这为服务器所支持cors请求类型和允许的自定义请求首部字段，以及支持跨域的源。\n实例代码 前端代码与发送普通请求没有差异，我们只需在服务端设置即可，以node为例：\nvar express = require('express'); var app = express(); var allowCrossDomain = function (req, res, next) { res.header('Access-Control-Allow-Origin', 'http://localhost:3001'); res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE'); res.header('Access-Control-Allow-Headers', 'Content-Type'); next(); } app.use(allowCrossDomain); 接下来，http://localhost:3001下的GET,PUT,POST,DELETE请求，自定义首部字段为Content-Type的非简单请求则会被正常访问，当然，你也可以将Access-control-Allow-Methods和Access-Control-Allow-Headers这两个配置删掉，删掉之后，将仅支持简单请求进行跨域。\nCORS字段介绍： （1）Access-Control-Allow-Methods\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。\n（2）Access-Control-Allow-Headers\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。\n（3）Access-Control-Allow-Credentials\n该字段与简单请求时的含义相同。\n（4）Access-Control-Max-Age\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。\n总结： 总的来说，使用CORS简单请求，非常容易，对于前端来说无需做任何配置，与发送普通ajax请求无异。唯一需要注意的是，需要携带cookie信息时，需要将withCredentials设置为true即可。CORS的配置，完全在后端设置，配置起来也比较容易，目前对于大部分浏览器兼容性也比较好。CORS优势也比较明显，可以实现任何类型的请求，相较于JSONP跨域只能使用get请求来说，也更加的便于我们使用。关于jsonp跨域请求的实现，可以参照我另外一篇文章jsonp跨域原理：https://blog.csdn.net/badmoonc/article/details/82289252\nCORS漏洞利用 配合XSS\n高级利用\nCORS漏洞防御 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\nhttps://www.freebuf.com/articles/web/204023.html\nhttps://blog.csdn.net/liu_xue_xue/article/details/107870251\n","description":"仅供学习参考","tags":["CORS"],"title":"CORS配置错误漏洞","uri":"/posts/web%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/cors%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E6%BC%8F%E6%B4%9E/"},{"categories":["Hugo"],"content":"博客发布时遇到的一个问题。\n原因：\nHugo图片插入，看到的其他人的做法大多是将其放在一个目录下，比如说static.\n但是我的vim插件使用的相对路径，图片都保存到当前目录下的pic文件夹中。在生成网页后，也全部采用的相对路径，导致图片路径未找到。\n好在，hugo应该是提供了解决方案的，之前还在困惑说为什么一个md文件，hugo会生成这个名字的目录，然后再是index.html。在这里同样利用一下。\n方法一：（不推荐）\ntypora图片位置为./\n创建一个名为Test文件夹，文件夹内创建一个Test.md，添加图片后，将Test.md移动到与文件夹同级\n方法二：\n不直接生成md文件作为某一篇post，而是新建文件夹，然后在其中创建文件夹，文件夹中存放index.md才是post的内容，多了一层。这样的好处就是，在这个post目录下，图片的pic文件夹就和md文件同级，可以引用，同时，hugo也会生成相应的目录，完美解决了图片的问题。\n采用方法二：\n使用hugo命令进行创建新文章\nhugo new posts/Hugo图片插入问题/index.md typora设置图片格式为./images\n效果如下图：\n","description":"","tags":["解决问题"],"title":"Hugo图片插入问题","uri":"/posts/hugo/hugo%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98/"},{"categories":["Hugo"],"content":"记录博客搭建过程。\n初始化环境 下载hugo-ex…\n添加到环境变量中\nhugo new site hugo-blog 主题 找一个主题下载\ngit clone https://github.com/adityatelange/hugo-PaperMod.git themes/hugo-PaperMod 配置 主题示例配置 https://adityatelange.github.io/hugo-PaperMod/ 部署 这部分需要使用到一个叫做github page的东西，是GitHub提供的一个网页寄存服务，可以寄存静态页面，这个特性就特别适合博客的搭建。\n首先再Github上创建一个 Repository，命名为Github名字.github.io，譬如我的仓库bansxf.github.io，这样就可以生成一个用户页面\n在hugo server调式页面完成后，使用命令hugo生成hugo静态页面。\n**注意！！！**在生成静态页面之前要把config.toml文件中的baseURL修改为自己博客的网址，譬如\n1 2 3  baseURL = \"https://bansxf.github.io/\" hugo ##生成静态页面文件 hugo -D ##连带着草稿一起生成静态文件   在命令执行后，出现一个public文件夹，里面就是网站的静态页面文件，进入public文件夹，使用git上传文件。\n1 2 3 4 5 6 7  cd public git init git add . git commit -m \"first commit\" git branch -M main git remote add origin git@github.com:bansxf/bansxf.github.io.git git push -u origin main   在此之后更新文章，使用hugo生成新的静态页面，后使用git push进行上传，commit -m 后面的东西是此次提交的备注。\n1 2 3  cd public git commit -m \"add blog post\" git push   ","description":"","tags":["blog"],"title":"搭建hugo博客","uri":"/posts/hugo/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/"},{"categories":["信息收集"],"content":"google搜索语法\ngoogleHacking语法库 https://www.exploit-db.com/google-hacking-database\n高级语法    关键字 含义     site 指定搜索域名（例：site:baidi.com）   inurl 指定url中是否含有某些关键字（例：inurl:.php?id=）   intext 指定页面是否含有某些关键字(例：intext:网站管理)   filetype 指定搜索文件类型（例：filetype:txt）   intitle 指定网页标题是否含有某些关键字（例：intitle:后台管理）   link 指定网页链接（例：link:baidu.com 指定与百度做了外链的站点）   info 指定搜索网页信息   cache 显示页面的缓存版本   numberange 搜索一个数字    通配符    通配符 语义 说明 示例     + 包含关键字 +前面必须有一个空格 admin +login   - 排除关键字 -前面必须有一个空格 mysql -csdn   ~ 同义词 同上 mysql ~csdn   * 模糊查询 *代替任意字符 mysql**   \"\" 强调 - “mysql”    google 黑客专用信息和资料搜索地址为： http://www.google.com/custom?hl=xx-hacker\n这里是google关键字的用法，要设置它为中文，则是 http://www.google.com/custom?hl=zh-CN 英文则是http://www.google.com/custom?hl=en\n示例 搜索目录\nintext:index of /|../|parent Directory 搜索上传页面：\ninurl:upload site:17173.com 搜索后台/登录页面：\nintitle:后台 site:tflamps.com inurl:/admin intext:后台管理系统 搜索可能存在注入的页面：\ninurl:?id= site:wd-bearings.com site:xxx.edu.cn inurl:?= 搜索可能存在文件包含的页面：\ninurl:?file= site:hkjc.com 谷歌语法子域名：\nsite:*.xx.com 目录搜索：\nparent directory site:testfire.net 参考 https://blog.csdn.net/xielinrui123/article/details/88866969\n","description":"","tags":["搜索"],"title":"Google Hacking","uri":"/posts/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/google-hacking/"},{"categories":["Hexo"],"content":"Hexo + Github 搭建 Blog 和 每次博客的部署\n 准备工作 1.安装git\ngit下载地址：链接 安装后验证\n1  git --version   出现类似下面的版本号，皆为成功 git version 2.19.2.windows.1\n2.安装node（其附带npm）\nnode.js下载地址：链接 安装后验证\n1  node -v   出现类似下面的版本号(安装最新版本)： v10.14.1\n3.安装Hexo 命令行输入：\n1  npm install -g hexo-cli   4.创建本地运行库\n创建本地仓库文件夹：例F:\\github 右键点击该文件夹，Git Bash Here，命令行输入\n1  hexo init myblog   初始化完成！\n本地试运行 1.进入博客根目录（myblog）\n1  cd myblog   2.安装\n1  npm install   3.运行 本地运行(如果4000端口被占用，使用 hexo service -p 5000 修改端口)\n1  hexo server   此时在浏览器输入 http://localhost:4000/ ,访问到博客界面\n部署在远程库 这里将其部署在github上\n1.创建Github账户\n略，随便百度一下\n2.创建github项目\n创建一个名为yourname.github.io的项目（yourname为你github名）\n3.生成密钥，用于ssh连接\n在本地，右键网站根目录，点击Git Bash 输入下列命令 yourname 即为github注册时的用户名 youremail 为注册时的邮箱账号 第三条命令生成密钥：\n1 2 3  git config --global user.name \"yourname\" git config --global user.email \"yourEmail\" ssh-keygen -t rsa -C \"yourEmail\"   此时在C:\\Users下你的当前账户文件夹下会有一个 .ssh 文件，找到id_rsa.pub文件，复制里面的内容，粘贴至GitHub中（点击右上角用户头像下的Settings，之后点击左侧的SSH and GPG keys，找到New SSH key点击，输入title，并将之前复制的内容粘贴到下面的key中），最后点击Add SSH key，完成。\n4.修改配置文件\n去博客根目录下的_config.yml文件中，添加如下（yourname就是GitHub的用户名）：\n1 2 3 4  deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master   5.将本地仓库同步到github\n在第一次生成以及部署之前，需要安装一个扩展：\n1  npm install hexo-deployer-git --save   清除生成的静态网页缓存数据\n1  hexo clean   生成文章对应的静态页面\n1  hexo g   部署本地站点到github命令\n1  hexo deploy   ","description":"","tags":["blog"],"title":"搭建Hexo博客","uri":"/posts/hexo/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"}]
